<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassProcessorService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">javaparser</a> &gt; <a href="index.source.html" class="el_package">org.rsk.doc.extractor.service</a> &gt; <span class="el_source">ClassProcessorService.java</span></div><h1>ClassProcessorService.java</h1><pre class="source lang-java linenums">package org.rsk.doc.extractor.service;

import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;

import java.util.*;
import java.util.stream.Stream;

import static org.rsk.doc.extractor.service.CommonUtil.processBinaryExprString;

<span class="fc" id="L24">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span>
public class ClassProcessorService {

<span class="fc" id="L27">    @Getter</span>
<span class="fc" id="L28">    private static final ClassProcessorService instance = new ClassProcessorService();</span>

<span class="fc" id="L30">    private final ClassWithFilterVisitor classWithFilterVisitor = new ClassWithFilterVisitor();</span>
<span class="fc" id="L31">    private final PropertiesService propertiesService = PropertiesService.getInstance();</span>
<span class="fc" id="L32">    private final DefaultParamService defaultParamService = DefaultParamService.getInstance();</span>

<span class="fc" id="L34">    private Map&lt;String, String&gt; modelStrings = new HashMap&lt;&gt;();</span>
<span class="fc" id="L35">    private Set&lt;String&gt; processedClasses = new HashSet&lt;&gt;();</span>
<span class="fc" id="L36">    private Set&lt;String&gt; undetectedClasses = new HashSet&lt;&gt;();</span>

    public void processClassAsType(String searchClassName) {
<span class="fc bfc" id="L39" title="All 2 branches covered.">        if(!processType(searchClassName)) {</span>
<span class="fc" id="L40">            return;</span>
        }
<span class="fc" id="L42">        Optional&lt;ClassOrInterfaceDeclaration&gt; searchClassOptional =</span>
<span class="fc" id="L43">            searchForClass(propertiesService.getParseResults(), searchClassName);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if(searchClassOptional.isPresent()) {</span>
<span class="fc" id="L45">            convertClassToModel(searchClassOptional.get());</span>
        } else {
<span class="fc" id="L47">            undetectedClasses.add(searchClassName);</span>
        }
<span class="fc" id="L49">    }</span>

    private Optional&lt;ClassOrInterfaceDeclaration&gt; searchForClass(
            List&lt;ParseResult&lt;CompilationUnit&gt;&gt; parseResults, String searchClassName) {
<span class="fc" id="L53">        Optional&lt;ClassOrInterfaceDeclaration&gt; searchClassOptional = parseResults.stream()</span>
<span class="fc" id="L54">            .map(parseResult -&gt; parseResult.getResult())</span>
<span class="fc" id="L55">            .filter(result -&gt; result.isPresent())</span>
<span class="fc" id="L56">            .flatMap(result -&gt; {</span>
<span class="fc" id="L57">                ClassCollectorStateWrapper classCollectorStateWrapper =</span>
                    new ClassCollectorStateWrapper(searchClassName);
<span class="fc" id="L59">                classWithFilterVisitor.visit(result.get(), classCollectorStateWrapper);</span>
<span class="fc" id="L60">                return classCollectorStateWrapper.getCollector().stream();</span>
            })
<span class="fc" id="L62">            .findFirst();</span>
<span class="fc" id="L63">        return searchClassOptional;</span>
    }

    private void convertClassToModel(ClassOrInterfaceDeclaration searchClass) {
<span class="fc" id="L67">        StringBuilder stringBuilder = new StringBuilder();</span>

<span class="fc" id="L69">        String className = searchClass.getName().getIdentifier();</span>
<span class="fc" id="L70">        String interfaceTitle = &quot;interface &quot; + className + &quot; {\n&quot;;</span>
<span class="fc" id="L71">        stringBuilder.append(interfaceTitle);</span>

<span class="fc" id="L73">        searchClass.getMembers()</span>
<span class="fc" id="L74">            .stream()</span>
<span class="fc" id="L75">            .flatMap(bodyDeclaration -&gt;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">                (bodyDeclaration.isFieldDeclaration())</span>
<span class="fc" id="L77">                    ? ((FieldDeclaration) bodyDeclaration).getVariables().stream()</span>
<span class="fc" id="L78">                    : Stream.empty()</span>
            )
<span class="fc" id="L80">            .forEach(variableDeclarator -&gt; {</span>
<span class="fc" id="L81">                String variableName = variableDeclarator.getName().getIdentifier();</span>
<span class="fc" id="L82">                String customDocumentationType = processListedClassesAndReturnDocumentationType(variableDeclarator);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">                String documentationType = StringUtils.isEmpty(customDocumentationType)</span>
<span class="fc" id="L84">                    ? variableDeclarator.getType().asString()</span>
                    : customDocumentationType;

<span class="fc" id="L87">                String processedLine = &quot;  &quot; + variableName + &quot;: &quot; + documentationType + &quot;;\n&quot;;</span>

<span class="fc" id="L89">                processClassAsType(variableDeclarator.getType().asString());</span>
<span class="fc" id="L90">                stringBuilder.append(processedLine);</span>
<span class="fc" id="L91">            });</span>

<span class="fc" id="L93">        stringBuilder.append(&quot;}&quot;);</span>
<span class="fc" id="L94">        modelStrings.put(className, stringBuilder.toString());</span>
<span class="fc" id="L95">        processedClasses.add(className);</span>
<span class="fc" id="L96">    }</span>

    private String processListedClassesAndReturnDocumentationType(VariableDeclarator variableDeclarator) {
<span class="fc" id="L99">        FieldDeclaration fieldDeclaration = (FieldDeclaration) variableDeclarator.getParentNode().get();</span>

<span class="fc" id="L101">        Optional&lt;AnnotationExpr&gt; jsonRpcDocModelType = fieldDeclaration.getAnnotations()</span>
<span class="fc" id="L102">            .stream()</span>
<span class="fc" id="L103">            .filter(annotationExpr -&gt; annotationExpr.getNameAsString().equals(&quot;JsonRpcDocModelType&quot;))</span>
<span class="fc" id="L104">            .findFirst();</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if(jsonRpcDocModelType.isPresent()) {</span>
<span class="fc" id="L107">            Map&lt;String, Expression&gt; processedPairValues = defaultParamService.getProcessedPairValues(</span>
<span class="fc" id="L108">                propertiesService.getAnnotationDefaultValues(),</span>
<span class="fc" id="L109">                jsonRpcDocModelType.get());</span>

<span class="fc" id="L111">            String setDocumentationType = processBinaryExprString(processedPairValues.get(&quot;documentationType&quot;));</span>

<span class="fc" id="L113">            processedPairValues.get(&quot;processClassNames&quot;)</span>
<span class="fc" id="L114">                .asArrayInitializerExpr()</span>
<span class="fc" id="L115">                .getValues()</span>
<span class="fc" id="L116">                .forEach(expression -&gt; processClassAsType(processBinaryExprString(expression)));</span>

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if(!StringUtils.isBlank(setDocumentationType)) {</span>
<span class="fc" id="L119">                return setDocumentationType;</span>
            }
        }
<span class="fc" id="L122">        return null;</span>
    }

    private Boolean processType(String type){
<span class="fc bfc" id="L126" title="All 4 branches covered.">        return !processedClasses.contains(type) &amp;&amp; !undetectedClasses.contains(type);</span>
    }

    public Map&lt;String, String&gt; getModelStrings() {
<span class="fc" id="L130">        return modelStrings;</span>
    }

    @Getter
    @Setter
    private static class ClassCollectorStateWrapper {
<span class="fc" id="L136">        private final String className;</span>
<span class="fc" id="L137">        private final List&lt;ClassOrInterfaceDeclaration&gt; collector;</span>

<span class="fc" id="L139">        public ClassCollectorStateWrapper(String className) {</span>
<span class="fc" id="L140">            this.className = className;</span>
<span class="fc" id="L141">            this.collector = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L142">        }</span>
    }

<span class="fc" id="L145">    private class ClassWithFilterVisitor extends VoidVisitorAdapter&lt;ClassCollectorStateWrapper&gt; {</span>
        @Override
        public void visit(ClassOrInterfaceDeclaration n, ClassCollectorStateWrapper wrapper) {
<span class="fc" id="L148">            super.visit(n, wrapper);</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">            if(wrapper.getClassName().equals(n.getNameAsString())) {</span>
<span class="fc" id="L151">                wrapper.getCollector().add(n);</span>
            }
<span class="fc" id="L153">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>