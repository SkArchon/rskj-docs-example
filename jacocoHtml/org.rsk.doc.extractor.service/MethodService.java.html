<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">javaparser</a> &gt; <a href="index.source.html" class="el_package">org.rsk.doc.extractor.service</a> &gt; <span class="el_source">MethodService.java</span></div><h1>MethodService.java</h1><pre class="source lang-java linenums">package org.rsk.doc.extractor.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.BinaryExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.NormalAnnotationExpr;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.rsk.doc.extractor.Constants;
import org.rsk.doc.extractor.dto.MethodAndAnnotation;
import org.rsk.doc.extractor.dto.yaml.output.*;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.rsk.doc.extractor.service.CommonUtil.processBinaryExprString;

<span class="fc" id="L30">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span>
public class MethodService {

<span class="fc" id="L33">    @Getter</span>
<span class="fc" id="L34">    private static final MethodService instance = new MethodService();</span>

<span class="fc" id="L36">    private final DefaultParamService defaultParamService = DefaultParamService.getInstance();</span>
<span class="fc" id="L37">    private final ExtractAnnotedMethodService extractAnnotedMethodService = ExtractAnnotedMethodService.getInstance();</span>
<span class="fc" id="L38">    private final PropertiesService propertiesService = PropertiesService.getInstance();</span>
<span class="fc" id="L39">    private final FileLoaderService fileLoaderService = FileLoaderService.getInstance();</span>
<span class="fc" id="L40">    private final ClassProcessorService classProcessorService = ClassProcessorService.getInstance();</span>

    private MethodAndAnnotation getPrimary(List&lt;MethodAndAnnotation&gt; methodAndAnnotationList) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">        if(methodAndAnnotationList.size() &gt; 1) {</span>
<span class="fc" id="L44">            Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues = propertiesService.getAnnotationDefaultValues();</span>
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">            for (MethodAndAnnotation methodAndAnnotation : methodAndAnnotationList) {</span>
<span class="fc" id="L46">                AnnotationExpr annotationExpr = methodAndAnnotation.getAnnotationExpr();</span>
<span class="fc" id="L47">                Map&lt;String, Expression&gt; processedPairValues = defaultParamService.getProcessedPairValues(annotationDefaultValues, annotationExpr);</span>

<span class="fc" id="L49">                Boolean isPrimary = processedPairValues.get(&quot;primaryForOverloads&quot;).asBooleanLiteralExpr().getValue();</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">                if (isPrimary) {</span>
<span class="fc" id="L51">                    return methodAndAnnotation;</span>
                }
<span class="fc" id="L53">            }</span>
        }
<span class="fc" id="L55">        return methodAndAnnotationList.get(0);</span>
    }

    public MethodDetails extractMethod(List&lt;MethodAndAnnotation&gt; methodAndAnnotationList) {
<span class="fc" id="L59">        Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues = propertiesService.getAnnotationDefaultValues();</span>

<span class="fc" id="L61">        MethodAndAnnotation methodAndAnnotation = getPrimary(methodAndAnnotationList);</span>
<span class="fc" id="L62">        MethodDeclaration methodDeclaration = methodAndAnnotation.getMethodDeclaration();</span>

<span class="fc" id="L64">        Map&lt;String, Expression&gt; processedPairValues = defaultParamService.getProcessedPairValues(</span>
<span class="fc" id="L65">            annotationDefaultValues, methodAndAnnotation.getAnnotationExpr());</span>

<span class="fc" id="L67">        String description = processBinaryExprString(processedPairValues.get(&quot;description&quot;));</span>

        // In case the user has not set a summary we substitute the description in
<span class="fc" id="L70">        String initialSummary = processBinaryExprString(processedPairValues.get(&quot;summary&quot;));</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        String summary = (StringUtils.isEmpty(initialSummary))</span>
            ? description
            : initialSummary;

<span class="fc" id="L75">        boolean isWriteMethod = processedPairValues.get(&quot;isWriteMethod&quot;).asBooleanLiteralExpr().getValue();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        MethodType methodType = isWriteMethod</span>
            ? MethodType.WRITE
            : MethodType.READ;

<span class="fc" id="L80">        Expression requestExampleExpression = processedPairValues.get(&quot;requestExamples&quot;);</span>

        // The javaparser library detects the type based on what is present
        // in the java file and not what is present in
        // the actual type therefore in case a user omits the
        // curly braces we do this
<span class="fc bfc" id="L86" title="All 2 branches covered.">        List&lt;Expression&gt; requestExampleExpressionsList = (requestExampleExpression.isArrayInitializerExpr())</span>
<span class="fc" id="L87">            ? requestExampleExpression.asArrayInitializerExpr().getValues()</span>
<span class="fc" id="L88">            : Arrays.asList(requestExampleExpression);</span>

<span class="fc" id="L90">        List&lt;String&gt; requestExampleEntries = requestExampleExpressionsList.stream()</span>
<span class="fc" id="L91">            .map(expression -&gt; {</span>
<span class="fc" id="L92">                String path = processBinaryExprString(expression);</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                return (StringUtils.isEmpty(path))</span>
                    ? null
<span class="fc" id="L95">                    : fileLoaderService.getValueFromPath(path);</span>
            })
<span class="fc" id="L97">            .filter(Objects::nonNull)</span>
<span class="fc" id="L98">            .collect(Collectors.toList());</span>

<span class="fc" id="L100">        List&lt;List&lt;InputParam&gt;&gt; inputParams = getInputParams(methodAndAnnotationList);</span>

<span class="fc" id="L102">        NodeList&lt;Expression&gt; responseArray = processedPairValues.get(&quot;responses&quot;).asArrayInitializerExpr().getValues();</span>
<span class="fc" id="L103">        List&lt;ResponseDetails&gt; responseDetails = getResponseDetails(responseArray, methodAndAnnotation);</span>

<span class="fc" id="L105">        String methodName = methodDeclaration.getNameAsString();</span>

<span class="fc" id="L107">        RequestDetails requestDetails = new RequestDetails(inputParams, requestExampleEntries);</span>
<span class="fc" id="L108">        return new MethodDetails(methodName, description, summary, methodType, requestDetails, responseDetails);</span>
    }

    private List&lt;ResponseDetails&gt; getResponseDetails(NodeList&lt;Expression&gt; responses, MethodAndAnnotation methodAndAnnotation) {
<span class="fc" id="L112">        Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues = propertiesService.getAnnotationDefaultValues();</span>

<span class="fc" id="L114">        return responses.stream()</span>
<span class="fc" id="L115">            .map(expression -&gt; {</span>
<span class="fc" id="L116">                AnnotationExpr annotation = (AnnotationExpr) expression;</span>
<span class="fc" id="L117">                Map&lt;String, Expression&gt; processedPairs = defaultParamService.getProcessedPairValues(annotationDefaultValues, annotation);</span>

<span class="fc" id="L119">                boolean isSuccess = processedPairs.get(&quot;success&quot;).asBooleanLiteralExpr().getValue();</span>
<span class="fc" id="L120">                String code = processBinaryExprString(processedPairs.get(&quot;code&quot;));</span>

<span class="fc" id="L122">                String processedDescription = getDescriptionAfterProcessing(processedPairs);</span>

<span class="fc" id="L124">                String examplePath = processBinaryExprString(processedPairs.get(&quot;examplePath&quot;));</span>
<span class="fc" id="L125">                String example = fileLoaderService.getValueFromPath(examplePath);</span>

                // This didnt seem it need to be set in the annotations
                // as the methods seemed to return either 200 or 500 when checked
<span class="fc bfc" id="L129" title="All 2 branches covered.">                Integer httpCode = (isSuccess)</span>
                    ? 200
                    : 500;

<span class="fc" id="L133">                String modelKey = processModelAndGetModelKey(</span>
<span class="fc" id="L134">                    methodAndAnnotation.getMethodDeclaration().getType(), processedPairs.get(&quot;attachModel&quot;).asBooleanLiteralExpr().getValue());</span>

<span class="fc" id="L136">                return new ResponseDetails(</span>
<span class="fc" id="L137">                    code, isSuccess, httpCode, processedDescription, example, modelKey);</span>
            })
<span class="fc" id="L139">            .collect(Collectors.toList());</span>
    }

    private String processModelAndGetModelKey(Type type, Boolean attachModel) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if(attachModel) {</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if(type instanceof ClassOrInterfaceType) {</span>
<span class="fc" id="L145">                ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;</span>
<span class="fc" id="L146">                String className = classOrInterfaceType.getName().getIdentifier();</span>
<span class="fc" id="L147">                classProcessorService.processClassAsType(className);</span>
<span class="fc" id="L148">                return className;</span>
            }
        }
<span class="fc" id="L151">        return null;</span>
    }

    private List&lt;List&lt;InputParam&gt;&gt; getInputParams(List&lt;MethodAndAnnotation&gt; methodAndAnnotationList) {
<span class="fc" id="L155">        Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues = propertiesService.getAnnotationDefaultValues();</span>

<span class="fc" id="L157">        List&lt;MethodAndAnnotation&gt; requestParamsList = methodAndAnnotationList.stream()</span>
<span class="fc" id="L158">            .map(entry -&gt; getRequestParamsOrdered(annotationDefaultValues, entry))</span>
<span class="fc" id="L159">            .collect(Collectors.toList());</span>

<span class="fc" id="L161">        Optional&lt;Integer&gt; highestValueOptional = requestParamsList.stream()</span>
<span class="fc" id="L162">            .map(expressions -&gt; expressions.getAnnotations().size())</span>
<span class="fc" id="L163">            .max(Comparator.comparing(Integer::valueOf));</span>

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (!highestValueOptional.isPresent()) {</span>
<span class="nc" id="L166">            return new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L169">        return IntStream.range(0, highestValueOptional.get())</span>
<span class="fc" id="L170">            .mapToObj(index -&gt;</span>
<span class="fc" id="L171">                groupInputParamsByIndexValue(annotationDefaultValues, requestParamsList, index))</span>
<span class="fc" id="L172">            .collect(Collectors.toList());</span>
    }

    private List&lt;InputParam&gt; groupInputParamsByIndexValue(Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues,
                                                          List&lt;MethodAndAnnotation&gt; requestParamsList,
                                                          int index) {
<span class="fc" id="L178">        List&lt;InputParam&gt; inputParams = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L179">        requestParamsList.forEach(methodAndAnnotation -&gt; {</span>
<span class="fc" id="L180">            List&lt;AnnotationExpr&gt; expressions = methodAndAnnotation.getAnnotations();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if(expressions.size() &gt; index) {</span>
<span class="fc" id="L182">                AnnotationExpr annotation = expressions.get(index);</span>
<span class="fc" id="L183">                Map&lt;String, Expression&gt; processedPairs = defaultParamService.getProcessedPairValues(annotationDefaultValues, annotation);</span>

<span class="fc" id="L185">                boolean usePrimary = processedPairs.get(&quot;usePrimary&quot;).asBooleanLiteralExpr().getValue();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (!usePrimary) {</span>
<span class="fc" id="L187">                    Parameter parameter = validateAndGetParameter(methodAndAnnotation.getMethodDeclaration(), processedPairs);</span>
<span class="fc" id="L188">                    String processedParameterName = getParameterName(processedPairs);</span>

<span class="fc" id="L190">                    String processedDescription = getDescriptionAfterProcessing(processedPairs);</span>

<span class="fc" id="L192">                    String modelKey = processModelAndGetModelKey(</span>
<span class="fc" id="L193">                        parameter.getType(),</span>
<span class="fc" id="L194">                        processedPairs.get(&quot;attachModel&quot;)</span>
<span class="fc" id="L195">                            .asBooleanLiteralExpr()</span>
<span class="fc" id="L196">                            .getValue());</span>

<span class="fc" id="L198">                    inputParams.add(new InputParam(</span>
                        processedParameterName, processedDescription, modelKey));
                }
            }
<span class="fc" id="L202">        });</span>
<span class="fc" id="L203">        return inputParams;</span>
    }

    private String getDescriptionAfterProcessing(Map&lt;String, Expression&gt; processedPairs) {
<span class="fc" id="L207">        String initialDescription = processBinaryExprString(processedPairs.get(&quot;description&quot;));</span>
<span class="fc" id="L208">        boolean loadDescriptionFromFile = processedPairs.get(&quot;loadDescriptionFromFile&quot;).asBooleanLiteralExpr().getValue();</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        return (loadDescriptionFromFile)</span>
<span class="fc" id="L211">            ? fileLoaderService.getValueFromPath(initialDescription)</span>
            : initialDescription;
    }

    private Parameter validateAndGetParameter(MethodDeclaration primaryMethodDeclaration, Map&lt;String, Expression&gt; processedPairs) {
<span class="fc" id="L216">        String parameterName = processBinaryExprString(processedPairs.get(&quot;name&quot;));</span>

<span class="fc" id="L218">        Optional&lt;Parameter&gt; matchingParameter = primaryMethodDeclaration.getParameters()</span>
<span class="fc" id="L219">            .stream()</span>
<span class="fc" id="L220">            .filter(parameter -&gt; parameter.getNameAsString().equals(parameterName))</span>
<span class="fc" id="L221">            .findFirst();</span>

        // The matching parameter should exist, otherwise its a documentation error
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (!matchingParameter.isPresent()) {</span>
<span class="nc" id="L225">            throw new RuntimeException(</span>
<span class="nc" id="L226">                &quot;There was no matching parameter present for &quot; + parameterName + &quot; and &quot; + primaryMethodDeclaration.getNameAsString());</span>
        }

<span class="fc" id="L229">        return matchingParameter.get();</span>
    }

    private MethodAndAnnotation getRequestParamsOrdered(Map&lt;String, Map&lt;String, Expression&gt;&gt; annotationDefaultValues,
                                                        MethodAndAnnotation entry) {
<span class="fc" id="L234">        Map&lt;String, Expression&gt; processedPairValues = defaultParamService.getProcessedPairValues(</span>
<span class="fc" id="L235">            annotationDefaultValues, entry.getAnnotationExpr());</span>
<span class="fc" id="L236">        NodeList&lt;Expression&gt; requestParams = processedPairValues.get(&quot;requestParams&quot;).asArrayInitializerExpr().getValues();</span>

<span class="fc" id="L238">        Map&lt;String, AnnotationExpr&gt; annotationExprByName = requestParams.stream()</span>
<span class="fc" id="L239">            .map(expression -&gt; {</span>
<span class="fc" id="L240">                AnnotationExpr annotationExpr = expression.asAnnotationExpr();</span>
<span class="fc" id="L241">                NormalAnnotationExpr normalAnnotationExpr = annotationExpr.asNormalAnnotationExpr();</span>
<span class="fc" id="L242">                Map&lt;String, Expression&gt; annotationParams = defaultParamService.convertPairsToMap(normalAnnotationExpr.getPairs());</span>

<span class="fc" id="L244">                String name = processBinaryExprString(annotationParams.get(&quot;name&quot;));</span>
<span class="fc" id="L245">                return new AbstractMap.SimpleEntry&lt;&gt;(name, annotationExpr);</span>
            })
<span class="fc" id="L247">            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span>

<span class="fc" id="L249">        List&lt;AnnotationExpr&gt; orderedExpressions = entry.getMethodDeclaration()</span>
<span class="fc" id="L250">            .getParameters()</span>
<span class="fc" id="L251">            .stream()</span>
<span class="fc" id="L252">            .map(parameter -&gt; annotationExprByName.get(parameter.getNameAsString()))</span>
<span class="fc" id="L253">            .collect(Collectors.toList());</span>

<span class="fc" id="L255">        return new MethodAndAnnotation(entry.getMethodDeclaration(), orderedExpressions);</span>
    }

    private String getParameterName(Map&lt;String, Expression&gt; processedPairs) {
<span class="fc" id="L259">        String parameterName = processBinaryExprString(processedPairs.get(&quot;name&quot;));</span>
<span class="fc" id="L260">        String parameterAlias = processBinaryExprString(processedPairs.get(&quot;alias&quot;));</span>

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        return (StringUtils.isEmpty(parameterAlias))</span>
            ? parameterName
            : parameterAlias;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>